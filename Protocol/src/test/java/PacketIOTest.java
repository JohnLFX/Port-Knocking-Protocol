import cnt4004.protocol.Packet;
import cnt4004.protocol.ProtocolMap;
import org.junit.Assert;
import org.junit.Test;

import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class PacketIOTest {

    @Test
    public void test() throws Exception {

        Field packetMapField = ProtocolMap.class.getDeclaredField("PACKET_MAP");
        packetMapField.setAccessible(true);
        //noinspection unchecked
        Map<Byte, Constructor<? extends Packet>> packetMap = (Map<Byte, Constructor<? extends Packet>>) packetMapField.get(null);

        Method createPacketMethod = ProtocolMap.class.getDeclaredMethod("createFromID", byte.class);
        createPacketMethod.setAccessible(true);

        List<Packet> packets = new ArrayList<>();

        for (byte id : packetMap.keySet()) {

            Packet packet = (Packet) createPacketMethod.invoke(null, id);

            Assert.assertNotNull("Packet object is null for registered packet ID", packet);
            Assert.assertEquals("ID in packet object does not match registered ID", id, packet.getID());

            Assert.assertTrue(packets.add(packet));

        }

        ProtocolMap.initializeHMAC(new SecretKeySpec("secret".getBytes(StandardCharsets.US_ASCII), "HmacSHA1"));

        ByteArrayOutputStream outBuffer = new ByteArrayOutputStream();
        DataOutputStream outSream = new DataOutputStream(outBuffer);

        for (Packet packet : packets) {

            int before = outSream.size();

            packet.write(outSream);

            int realLength = outSream.size() - before;

            Assert.assertEquals("Packet length generated by Packet#write(...)" +
                    " does not match value in Packet#length()", realLength, packet.length());

            // Now see if the data can be read back
            DataInputStream inStream = new DataInputStream(new ByteArrayInputStream(outBuffer.toByteArray()));
            packet.read(inStream); // An unsuccessful read throws an exception

            // It read the packet back correctly
            inStream.close();

            // Now check to see if the encoded and decoded payloads are correct
            byte[] encodedPayload = ProtocolMap.generatePayload(packet);

            Packet decodedPacket = ProtocolMap.decodePayload(encodedPayload);

            Assert.assertNotNull("Decoded packet is null", decodedPacket);
            Assert.assertEquals("Decoded packet ID does not match encoded packet ID", packet.getID(), decodedPacket.getID());

            // Check fields
            for (Field field : packet.getClass().getDeclaredFields()) {

                field.setAccessible(true);

                Assert.assertEquals(field.get(packet), field.get(decodedPacket));

            }

            // Reset buffer
            outBuffer.reset();

        }

        outSream.close();

    }

}
