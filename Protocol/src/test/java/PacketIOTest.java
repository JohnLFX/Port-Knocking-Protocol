import cnt4004.protocol.Packet;
import cnt4004.protocol.ProtocolMap;
import cnt4004.protocol.SignedPacket;
import cnt4004.protocol.TrustedClient;
import org.junit.Assert;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.util.*;

public class PacketIOTest {

    @Test
    public void test() throws Exception {

        Field packetMapField = ProtocolMap.class.getDeclaredField("PACKET_MAP");
        packetMapField.setAccessible(true);
        //noinspection unchecked
        Map<Byte, Constructor<? extends Packet>> packetMap = (Map<Byte, Constructor<? extends Packet>>) packetMapField.get(null);

        Method createPacketMethod = ProtocolMap.class.getDeclaredMethod("createFromID", byte.class);
        createPacketMethod.setAccessible(true);

        List<Packet> packets = new ArrayList<>();

        for (byte id : packetMap.keySet()) {

            Packet packet = (Packet) createPacketMethod.invoke(null, id);

            Assert.assertNotNull("Packet object is null for registered packet ID", packet);
            Assert.assertEquals("ID in packet object does not match registered ID", id, packet.getID());

            Assert.assertTrue(packets.add(packet));

        }

        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);

        //KeyPair serverKeyPair = kpg.generateKeyPair();
        KeyPair clientKeyPair = kpg.generateKeyPair();

        TrustedClient client = new TrustedClient("com1", clientKeyPair.getPublic());

        ProtocolMap.initializeSignature(new HashSet<>(Collections.singletonList(client)), clientKeyPair.getPrivate());

        ByteArrayOutputStream outBuffer = new ByteArrayOutputStream();
        DataOutputStream outStream = new DataOutputStream(outBuffer);

        for (Packet packet : packets) {

            if (packet instanceof SignedPacket)
                ((SignedPacket) packet).setClientIdentifier(client.getIdentifier());

            int before = outStream.size();

            packet.write(outStream);

            int realLength = outStream.size() - before;

            Assert.assertEquals("Packet length generated by Packet#write(...)" +
                    " does not match value in Packet#length()", realLength, packet.length());

            // Now see if the data can be read back
            DataInputStream inStream = new DataInputStream(new ByteArrayInputStream(outBuffer.toByteArray()));
            packet.read(inStream); // An unsuccessful read throws an exception

            // It read the packet back correctly
            inStream.close();

            // Now check to see if the encoded and decoded payloads are correct
            byte[] encodedPayload = ProtocolMap.encodePacket(packet);

            Packet decodedPacket = ProtocolMap.decodePayload(encodedPayload);

            Assert.assertNotNull("Decoded packet is null", decodedPacket);
            Assert.assertEquals("Decoded packet ID does not match encoded packet ID", packet.getID(), decodedPacket.getID());

            // Check fields
            for (Field field : packet.getClass().getDeclaredFields()) {

                field.setAccessible(true);

                Assert.assertEquals(field.get(packet), field.get(decodedPacket));

            }

            // Reset buffer
            outBuffer.reset();

        }

        outStream.close();

    }

}
